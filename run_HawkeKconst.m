% run_HawkePoisR(3,'x2020-03-14', 'x2020-03-16', 'confirm')
% run_HawkePoisR(3,'x2020-03-14', 'x2020-03-16', 'confirm')
% run_HawkePoisR(3,'x2020-03run_HawkeKconst(d_pred_start, type_case, muReg, alphaScale, betaShape)-14', 'x2020-03-16', 'confirm')
% run_HawkeKconst('x2020-10-04', 'confirm', '3', '2')


function [] = run_HawkeKconst(d_pred_start, type_case, alphaScale, betaShape)

%maxNumCompThreads(1);
Method = 'UHPOnly';

%% Read in job parameter
%delta = 3;  d_pred_start = 'x2020-03-14';   d_pred_end   = 'x2020-03-16';   type_case = 'confirm';
% delta = str2num(delta);
%out_save = ['./mdl/' Method '/Mdl_' type_case '_delta_' num2str(delta) '_pd_start_' d_pred_start '_pd_end_' d_pred_end '.mat'];

out_save = ['./mdl/' Method '/' Method '_Spain_type_' type_case '_alpha_' alphaScale '_beta_' betaShape '_predat_' d_pred_start(2:end) '.mat'];

disp(exist(out_save, 'file'))
disp(out_save)
if exist(out_save, 'file') == 2
        %exit
else
end

alphaScale_in = str2num(alphaScale);
betaShape_in  = str2num(betaShape);

%% Processes data
[covid_tr, covid_te, n_cty, n_day_tr, n_day_te] = HawkeKconst_input(type_case, d_pred_start, 20);

%
%% Define Parameters 
T = n_day_tr;
% Boundary correction, the number of days before the total number of days (n_day)
dry_correct = 14;

% EM step iterations
emiter = 200; %Nt=covid(:,2:end);
break_diff = 10^-3;

% Boundary correction: T-dry_correct
% Mobility has only 6 weeks so we take the less by min(T-dry_correct, size(mobi_in,2) )
day_for_tr = min(T-dry_correct, size(covid_tr,2) );

%% Initialize Inferred Parameters 
% Weibull Distribution (scale, shape) parameters as (alphas, betas)
if (alphaScale_in==0) && (betaShape_in==0)
    % Weibull Distribution (scale, shape) parameters as (alphas, betas)
    alpha  = 2;   beta = 2;
else
    alpha  = alphaScale_in;
    beta = betaShape_in;
end

% initial wbl values
wbl_val = repmat(sparse(tril(wblpdf( (1:n_day_tr).' - (1:n_day_tr), alpha, beta))), n_cty, 1);

% K0 reproduction number, a fuction of time and mobility.
% K0 is a n_county * n_day by n_day matrix.
% Estimat for each county at each day.
% each chunk n_day by n_day is a n_day times REPETITION for day j
K0 = ones(n_cty, n_day_tr);
K0_ext_j = repelem( K0, n_day_tr, 1);

% q is a n_county * n_day by n_day matrix.
% q( i, j), i > j stands the probability of ONE SIGLE event at day i triggered by ONE SIGLE event at day j
% i.e., Prob for each j triggered by each i
% each chunk n_day by n_day is for one county
q = sparse(n_cty * n_day_tr,n_day_tr);

% Mu is the back ground rate
mus=0.5*ones(n_cty,1);

% lam is the event intensity
lam = zeros(n_cty,T);

%% EM interation
alpha_delta = []; alpha_prev = [];
beta_delta = [];  beta_prev = [];
mus_delta = [];   mus_prev = [];
K0_delta = [];    K0_prev = [];
%theta_delta = []; theta_prev = [];

for itr = 1:emiter
    
    %% E-step

    q = K0_ext_j .* wbl_val .* ( covid_tr_ext_j(covid_tr, n_day_tr) >0);

    eye_mu = repmat( sparse(eye(n_day_tr)) , n_cty, 1) .* repelem(mus, n_day_tr, 1);
    eye_mu = full(eye_mu);

    lam = sum( q .* covid_tr_ext_j(covid_tr, n_day_tr) +  eye_mu, 2);
    lam_eq_zero = find(lam==0);

    q = q./lam;

    q(lam_eq_zero, :) = 0;

    lam = reshape( lam, n_day_tr, n_cty).';


    %% M-step
    % Calculate Q, which stands for the average number (observed) of children generated by a SINGLE event j
    % Note taht the last "dry_correct" days of Q will be accurate
    % Since we haven't observed their children yet
    Q = reshape( q .* covid_tr_ext_i(covid_tr, n_day_tr, n_cty), n_day_tr, n_day_tr*n_cty);
    Q = reshape( sum(Q,1), n_cty, n_day_tr);

    %% Estimate K0 at constant
    
    % boundaty correct 
    glm_y = Q(:, 1:day_for_tr);  

    % weight for observation, which is the number of evets at day j
    freqs = covid_tr(:, 1:day_for_tr);
    
    K0_const = sum(glm_y.*freqs,2)./sum(freqs,2);
    K0_const(find(sum(freqs,2)==0))=0;
    K0 = repmat( K0_const,1,size(covid_tr,2));
    K0(K0>2)=2;
    
    %tic
    lam_eq_zero = find(lam(:, 1:day_for_tr)==0);
    mus = (mus ./ lam(:, 1:day_for_tr));
    mus(lam_eq_zero) = 0;

    mus = sum(  mus .* covid_tr(:, 1:day_for_tr), 2) / day_for_tr;

    if (sum( isnan(mus) )>0)
        disp(['QQ'])
    end
    %% Estimate alpha and beta in Weibull Distribution

    if (alphaScale_in==0) && (betaShape_in==0)
        %tic
        obs = sparse( tril( (1:day_for_tr).' - (1:day_for_tr), -1) );

        freq = covid_tr_ext_j(covid_tr, n_day_tr) .* covid_tr_ext_i(covid_tr, n_day_tr, n_cty) .* q;
        freq = full(freq);
        freq = sum( permute( reshape(freq, n_day_tr, n_cty, n_day_tr), [1, 3, 2]), 3);
        freq = freq(1:day_for_tr, 1:day_for_tr);

        Ind_ret = find( (obs > 0) & (freq > 0) ) ;
        obs = obs(Ind_ret);
        freq = freq(Ind_ret);
        %toc
        %disp(toc)
        % Fit weibull
        %tic
        [coef,~] = wblfit(obs,[],[],freq);
        %toc
        %disp(toc)
        alpha=full(coef(1)); % scale
        beta=full(coef(2));  % shape
        %wbl_val = repmat(sparse(tril(wblpdf( (1:n_day_tr).' - (1:n_day_tr), alpha, beta))), n_cty, 1);
        if beta > 20
            beta = 20;
        end
        if alpha > 20
            alpha = 20;
        end
        
        wbl_val = repmat(sparse(tril(wblpdf( (1:n_day_tr).' - (1:n_day_tr), alpha, beta))), n_cty, 1);
    else
        alpha  = alphaScale_in;
        beta = betaShape_in;
    end

    

    %% check for the convergence
    if(itr==1)
        % save the first value
        alpha_prev = alpha; beta_prev = beta; mus_prev = mus; K0_prev = K0; %theta_prev = mdl.Coefficients.Estimate;
    else
        % Calculate the RMSR
        alpha_delta = [alpha_delta sqrt( (alpha-alpha_prev).^2 )];
        beta_delta  = [beta_delta  sqrt( (beta-beta_prev).^2 )];
        mus_delta   = [mus_delta sqrt( sum((mus_prev - mus).^2)/numel(mus) )];
        K0_delta    = [K0_delta sqrt( sum(sum((K0_prev - K0).^2))/numel(K0) )];
        % save the current
        alpha_prev = alpha; beta_prev = beta; mus_prev = mus; K0_prev = K0;% theta_prev = mdl.Coefficients.Estimate;
    end
    
    [wblstat_M, wblstat_V]=wblstat(alpha, beta);
    %%%%%%%%%%%%%%%%%%
    % Early Stop
    %%%%%%%%%%%%%%%%%%

    if (itr > 5)
        rule = all( alpha_delta(end-4:end) < break_diff) & all( beta_delta(end-4:end) < break_diff);
        rule = rule &  all( mus_delta(end-4:end) < break_diff) & all( K0_delta(end-4:end) < break_diff);

        if( rule )
            break;
        end
    end

    disp(itr)
    %disp(mdl)
    %disp(mdl.Rsquared)
    %disp(max(K0(:)))
    
    alpha_shape = alpha;
    beta_scale = beta;
    R0 = full(K0(:, 1));
end
%%
%%save(out_save,'mus','alpha','beta','K0','alpha_delta','beta_delta','mus_delta','K0_delta');
%save(out_save,'mus','alpha','beta','K0','VarNames','alpha_delta','beta_delta','mus_delta','K0_delta','theta_delta');
save(out_save,'mus','alpha_shape','beta_scale','R0');
end

function [covid_tr_ext_j] = covid_tr_ext_j(covid_tr, n_day_tr)
    covid_tr_ext_j = repelem(covid_tr, n_day_tr, 1);
end

function [covid_tr_ext_i] = covid_tr_ext_i(covid_tr, n_day_tr, n_cty)
    covid_tr_ext_i = repmat( cell2mat(mat2cell(covid_tr.', n_day_tr, ones(1, n_cty) ).'),  1, n_day_tr);
end

